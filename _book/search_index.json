[["basics-of-r-part-2.html", "3 Basics of R (Part 2) 3.1 Data structures 3.2 For loops 3.3 Functions", " 3 Basics of R (Part 2) In this chapter, we will learn powerful tools invaluable to our data science workflow. For instance, we will create our very own functions, which will allow us to solve increasingly complex problems. 3.1 Data structures Data structures determine the operations/methods/functions are available for each object. For example, you can do +/-/*// for numbers, but these operations will not be available for strings. What operations do you imagine would be useful for strings? paste(&quot;hello&quot;, &quot;world&quot;, sep = &quot;,&quot;) ## [1] &quot;hello,world&quot; Notice that single and double quotes can be used interchangeably, but double quotes are preferred. Single quotes are normally used to delimit characters within double quotes. 3.1.1 Vectors Vectors are a sequence of values with the same type. We can create vectors using c(), which stands for “combine”. (sites &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; To access the elements inside a vector, we can do something called “slicing”. To access a single item or multiple items, use the square bracket operator []. In general [] in R means, “give me a piece of something”. For example: sites[4] ## [1] &quot;c&quot; sites[1:3] ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; In sites[1:3], the 1:3 creates a vector from 1 to 3, which is then used to subset multiple items in a vector. Here are some additional useful functions: length(sites) ## [1] 4 density_ha &lt;- c(2.8, 3.2, 1.5, 3.8) mean(density_ha) ## [1] 2.825 max(density_ha) ## [1] 3.8 min(density_ha) ## [1] 1.5 sum(density_ha) ## [1] 11.3 We can also use logical operators on vectors. In the next example, we compare a vector to a single value, and operator returns one logical per value. c(1, 1, 2, 3, 1) == 1 ## [1] TRUE TRUE FALSE FALSE TRUE In English, the above snippet checks if each value in the vector is equal to 1. This is essentially what goes on behind the scenes when we try to subset a vector, except subsetting only returns where the subset condition is TRUE. Let’s look at an example where we have a vector of sites and a vector of US states they occur in. site &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) state &lt;- c(&#39;FL&#39;, &#39;FL&#39;, &#39;GA&#39;, &#39;AL&#39;) Now, let’s check if the state is 'FL'. This should return a vector of TRUE and FALSE. state == &#39;FL&#39; ## [1] TRUE TRUE FALSE FALSE Now, let’s filter the site vector to return values where the state is equal to 'FL'. site[state == &#39;FL&#39;] ## [1] &quot;a&quot; &quot;b&quot; The above snippet is the equivalent to passing a vector of TRUE and FALSE values inside the square brackets: site[c(TRUE, TRUE, FALSE, FALSE)] ## [1] &quot;a&quot; &quot;b&quot; Now we turn our attention to multiple vectors. If our vectors are the same length, we can use math operations to combine each index element-wise. density_ha &lt;- c(2.8, 3.2, 1.5, 3.8) area_ha &lt;- c(3, 5, 1.9, 2.7) (total_number &lt;- density_ha * area_ha) ## [1] 8.40 16.00 2.85 10.26 Subsetting across multiple vectors is the same as that for a single vector: # recall: sites &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # recall: area_ha &lt;- c(3, 5, 1.9, 2.7) area_ha[sites == &quot;a&quot;] ## [1] 3 5 The above code snippet selects all members of area_ha at the indices where sites == 'a'. This brings us to another important concept: == asks “does it equal to?” in most programming languages. == is not the same as =. This is why we use &lt;- to assign things instead of =. We can also ask the question of “does it not equal to?” area_ha[sites != &quot;a&quot;] ## [1] 1.9 2.7 Likewise, we can check “is it greater or less than?” sites[area_ha &gt; 3] ## [1] &quot;a&quot; sites[area_ha &gt;= 3] ## [1] &quot;a&quot; &quot;a&quot; sites[area_ha &lt; 3] ## [1] &quot;b&quot; &quot;c&quot; Notice that all the questions we ask have a “yes” (True) or “no” (False) answer. The operators associated with these questions are called Boolean operators. Finally, we can subset a vector based on itself. sites[sites != &quot;a&quot;] ## [1] &quot;b&quot; &quot;c&quot; 3.1.2 Missing values So far we’ve worked with data with no missing values. In real life, however, we often have missing values (NA values). Unfortunately for us, R does not get along with NA values. density_ha &lt;- c(2.8, 3.2, 1.5, NA) mean(density_ha) ## [1] NA Please note that NA is different from NULL. Take a look at the following example. na_vector &lt;- c(1, 2, 3, NA) null_vector &lt;- c(1, 2, 3, NULL) # look at the NA vector... na_vector ## [1] 1 2 3 NA # ... now look at the NULL vector null_vector ## [1] 1 2 3 # do the vectors work with a function such as mean()? mean(na_vector) ## [1] NA mean(null_vector) ## [1] 2 Why did we get NA? Well, it’s hard to say what a calculation including NA should be, so most calculations return NA when NA is in the data. One way to resolve this issue is to tell our function to remove the NA before executing: mean(density_ha, na.rm = TRUE) ## [1] 2.5 3.1.3 Data frames This is where things get really exciting! We will use these data structures extensively in the upcoming labs, so it’s important to pay attention here. A data frame is a list of equal length vectors grouped together. More importantly, a data frame can contain both categorical and numerical values, whereas a vector can only contain variables of the same type (i.e., all numerical, all categorical, etc.). surveys &lt;- data.frame(sites, density_ha, area_ha) surveys ## sites density_ha area_ha ## 1 a 2.8 3.0 ## 2 a 3.2 5.0 ## 3 b 1.5 1.9 ## 4 c NA 2.7 Here are some useful commands to investigate a data frame: str() returns the structure of a data frame. length() returns the length of a data frame. ncol() returns the number of columns of a data frame (same as length()) nrow() returns the number of rows of a data frame. str(surveys) ## &#39;data.frame&#39;: 4 obs. of 3 variables: ## $ sites : Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 1 2 3 ## $ density_ha: num 2.8 3.2 1.5 NA ## $ area_ha : num 3 5 1.9 2.7 length(surveys) ## [1] 3 ncol(surveys) ## [1] 3 nrow(surveys) ## [1] 4 Subsetting data frames is extremely similar to that for vectors. This time, however, we need to consider both rows and columns. We can access a specific member like this: my_data_frame[row, column] # visit one cell by row and column surveys[1, 2] ## [1] 2.8 # visit a range of rows and columns surveys[1:2, 2:3] ## density_ha area_ha ## 1 2.8 3 ## 2 3.2 5 # every row on the third column surveys[, 3] ## [1] 3.0 5.0 1.9 2.7 # visit column by name surveys[&#39;area_ha&#39;] ## area_ha ## 1 3.0 ## 2 5.0 ## 3 1.9 ## 4 2.7 # visit column by name (preferred method) surveys$area_ha ## [1] 3.0 5.0 1.9 2.7 # visit column by name surveys[[&#39;area_ha&#39;]] ## [1] 3.0 5.0 1.9 2.7 # visit multiple columns (preferred method) surveys[c(&#39;area_ha&#39;, &#39;sites&#39;)] ## area_ha sites ## 1 3.0 a ## 2 5.0 a ## 3 1.9 b ## 4 2.7 c 3.1.4 External data We can read in external data using theread.csv() function. The main argument is the location of the data, which is either a url or a path on your computer. shrub_data &lt;- read.csv(&#39;https://datacarpentry.org/semester-biology/data/shrub-dimensions-labeled.csv&#39;) 3.1.5 Factors Let’s use the str() function to get more information about our variable shrub_data. str(shrub_data) ## &#39;data.frame&#39;: 10 obs. of 4 variables: ## $ shrubID: Factor w/ 10 levels &quot;a1&quot;,&quot;a2&quot;,&quot;b1&quot;,..: 1 2 3 4 5 6 7 8 9 10 ## $ length : num 2.2 2.1 2.7 3 3.1 2.5 1.9 1.1 3.5 2.9 ## $ width : num 1.3 2.2 1.5 4.5 3.1 2.8 1.8 0.5 2 2.7 ## $ height : num 9.6 7.6 2.2 1.5 4 3 4.5 2.3 7.5 3.2 Notice that the shrubID column has type Factor. A factor is a special data type in R for categorical data. Factors are useful for statistics, but can mess up some aspects of computation as we’ll see in future chapters. shrub_data &lt;- read.csv(&#39;https://datacarpentry.org/semester-biology/data/shrub-dimensions-labeled.csv&#39;, stringsAsFactors = FALSE) str(shrub_data) ## &#39;data.frame&#39;: 10 obs. of 4 variables: ## $ shrubID: chr &quot;a1&quot; &quot;a2&quot; &quot;b1&quot; &quot;b2&quot; ... ## $ length : num 2.2 2.1 2.7 3 3.1 2.5 1.9 1.1 3.5 2.9 ## $ width : num 1.3 2.2 1.5 4.5 3.1 2.8 1.8 0.5 2 2.7 ## $ height : num 9.6 7.6 2.2 1.5 4 3 4.5 2.3 7.5 3.2 3.1.6 Lists Lists are a vector-like structure that can store other objects/data structures. It’s sort of like a vector that holds vectors. The main difference between a list and data frame is that lists can have elements with an unequal length. sites &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) notes &lt;- &quot;It was a good day in the field today. Warm, sunny, lots of gators.&quot; helpers &lt;- 4 field_notes &lt;- list(sites, notes, helpers) field_notes[1] ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; field_notes[[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; We can also give the values names and access them using the $ symbol (preferred) or via [&quot;variable_name&quot;] with subsetting. field_notes &lt;- list(my_sites = sites, notes = notes, my_helpers = helpers) field_notes$my_sites ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; field_notes[[&quot;my_sites&quot;]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 3.2 For loops Loops are fundamental a programming concept as they get a lot of repetitive stuff done in very few lines of code. You can think of loops as something that performs the same operation on a lot of things. Here’s what the syntax of a loop looks like: for (item in list_of_items) { do_something(item) } And here is an example: for (i in 1:5) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 The above snippet is equivalent to this: print(1) print(2) print(3) print(4) print(5) You can also have multiple lines of code in the body of a loop. for (number in 1:5) { number &lt;- number*2 print(number) } ## [1] 2 ## [1] 4 ## [1] 6 ## [1] 8 ## [1] 10 In the previous examples, we used the dummy variables i and number to take on some range of values. Notice that i can be called anything you want. To contexualize this, let’s look at an example that calculates mass using the following fomula: \\(\\text{mass} = \\text{density} \\times \\text{volume}\\) density &lt;- 2.65 volumes &lt;- c(1.6, 3, 8) for (i in 1:length(volumes)) { mass &lt;- density * volumes[i] print(mass) } ## [1] 4.24 ## [1] 7.95 ## [1] 21.2 Looping with an index allows us to store results calculated in the loop. In the following snippet, we are going to create an empty vector with sthe length of our volumes vector. ( masses &lt;- vector(mode = &quot;numeric&quot;, length = length(volumes)) ) ## [1] 0 0 0 Note that &quot;numeric&quot; is the type of data we are going to store and length(volumes) is the desired length of our vector. Now, add each result in the correct position—for each iteration through the loop, save the output in the empty vector (masses) at the i’th position. for (i in 1:length(volumes)){ mass &lt;- 2.65 * volumes[i] masses[i] &lt;- mass } masses ## [1] 4.24 7.95 21.20 3.2.1 Looping over multiple files We turn our attention now to a (slightly more) useful example: how do we analyze multiple files with similar contents? In this hypothetical example, we have 5 datasets with satellite coodinates at specific points orbiting the Earth. Suppose the files are similarly named (click on the files to download them): locations-2016-01-01.txt locations-2016-01-02.txt locations-2016-01-03.txt locations-2016-01-04.txt locations-2016-01-05.txt Our goal is to determine the number of satellite coordinates per file. First, retrieve the name of each file. data_files &lt;- list.files(path = &quot;data/02_intro-to-r/&quot;, pattern = &quot;locations-.*.txt&quot;, full.names = TRUE) Note that the asterisk in &quot;*.txt&quot; refers to “any name in this directory” whereas the &quot;.txt&quot; part ensures we are only selecting .txt files. Next, determine the number of observations in each file. We will assume that each row corresponds to a single coordinate. results &lt;- vector(mode = &quot;integer&quot;, length = length(data_files)) for (i in 1:length(data_files)) { data &lt;- read.csv(data_files[i]) count &lt;- nrow(data) results[i] &lt;- count } Now, store the output in a data frame and associate the file name with the count. results &lt;- data.frame(file_name = character(length(data_files)), count = integer(length(data_files)), stringsAsFactors = FALSE) for (i in 1:length(data_files)){ data &lt;- read.csv(data_files[i]) count &lt;- nrow(data) results$file_name[i] &lt;- data_files[i] results$count[i] &lt;- count } results ## file_name count ## 1 data/02_intro-to-r//locations-2016-01-01.txt 4 ## 2 data/02_intro-to-r//locations-2016-01-02.txt 8 ## 3 data/02_intro-to-r//locations-2016-01-03.txt 10 ## 4 data/02_intro-to-r//locations-2016-01-04.txt 10 ## 5 data/02_intro-to-r//locations-2016-01-05.txt 12 Voila! With the knowledge in this chapter, you are ready to solve some real-world problems 😄 3.2.2 Nested loops (OPTIONAL) Sometimes, we need to loop over more than a single range of numbers. For example, what if we want to select all pixels on a 3x4 rectangular screen? Here, we need to cover both the “x” and “y” pixel coodinates: for (i in 1:3) { for (j in 1:4) { print(paste(&quot;i = &quot; , i, &quot;; j = &quot;, j)) } } ## [1] &quot;i = 1 ; j = 1&quot; ## [1] &quot;i = 1 ; j = 2&quot; ## [1] &quot;i = 1 ; j = 3&quot; ## [1] &quot;i = 1 ; j = 4&quot; ## [1] &quot;i = 2 ; j = 1&quot; ## [1] &quot;i = 2 ; j = 2&quot; ## [1] &quot;i = 2 ; j = 3&quot; ## [1] &quot;i = 2 ; j = 4&quot; ## [1] &quot;i = 3 ; j = 1&quot; ## [1] &quot;i = 3 ; j = 2&quot; ## [1] &quot;i = 3 ; j = 3&quot; ## [1] &quot;i = 3 ; j = 4&quot; Here’s a slightly more complex example that finds all prime numbers from 1 to 15: for (i in 2:15) { # assume each number is prime by default prime &lt;- TRUE for (j in 2:(i-1)) { # if i is divisible by any number from 2 to i-1, it is not a prime if (i%%j == 0) { prime &lt;- FALSE } } if (prime == TRUE | i == 2) { print(paste(i, &quot;is prime&quot;)) } } ## [1] &quot;2 is prime&quot; ## [1] &quot;3 is prime&quot; ## [1] &quot;5 is prime&quot; ## [1] &quot;7 is prime&quot; ## [1] &quot;11 is prime&quot; ## [1] &quot;13 is prime&quot; 3.3 Functions Sometimes, R will leave us wanting for custom functions. Luckily, we can define our own functions! This is the general syntax for a function: function_name &lt;- function(arguments) { output_value &lt;- do_something(inputs) return(output_value) } Remark: every function returns a value. Recall from your grade-school math class that functions take an input and return an output. In R, however, a function may or may not take user-defined input. This brings me to an extremely important point: creating a function does NOT run it. You must call the function to run it. A function is meant to be reusable—treat it as such. # define the function calc_shrub_vol &lt;- function(length, width, height) { area &lt;- length * width volume &lt;- area * height return(volume) } # call the function calc_shrub_vol(0.8, 1.6, 2.0) ## [1] 2.56 As always, to save a function’s return value, you need to store the output in an appropriate data structure. shrub_vol &lt;- calc_shrub_vol(0.8, 1.6, 2.0) A helpful tip is to treat functions like a black box—the only things a function “knows” are the inputs we pass it. Likewise, the only thing R “knows” about a function is the output the function returns. Let’s walk through calc_shrub_vol()’s execution (key terms are in bold): Call the calc_shrub_vol() function. Within the function, Assign 0.8 to length, 1.6 to width, and 2.0 to height inside the function. Calculate the area and assign it to area. Calculate volume and assign it to volume. Return volume as the function output. Assign the function’s output to a new variable called shrub_vol. Since R treats functions like a black box, you can’t access a variable that was created in a function. You must save the output of a function (to a variable) to use it later. 3.3.1 Conditionals within functions Recall that we used a conditional to estimate mass differently for different types of vegetation. Since this is the kind of code we are going to want to reuse, let’s move it into a function. est_mass &lt;- function(volume, veg_type) { if (veg_type == &quot;tree&quot;) { mass &lt;- 2.65 * volume^0.9 } else if (veg_type == &quot;grass&quot;) { mass &lt;- 0.65 * volume^1.2 } else { mass &lt;- NA } return(mass) } We can then run this function with different vegetation types and get different estimates for mass. est_mass(1.6, &quot;tree&quot;) ## [1] 4.045329 est_mass(1.6, &quot;grass&quot;) ## [1] 1.142503 est_mass(1.6, &quot;shrub&quot;) ## [1] NA Let’s walk through how est_mass(1.6, &quot;shrub&quot;) executes: When we call est_mass(), the function assigns 1.6 to volume and &quot;shrub&quot; to veg_type. The function checks if veg_type is equal to &quot;tree&quot;. It isn’t, so it checks if veg_type is equal to &quot;grass&quot;. It isn’t, so it goes to the else statement and executes the code in that block. Hee, the function assignsNA to mass. The function exits the if/else if/else blocks and returns the value for mass, which is NA. 3.3.2 Nested conditionals Occasionally, we need to make complex decisions that can’t be captured using a simple if/else if/else statement. For example, we might have different equations for some vegetation types based on the age of the plant. To solve this problem, we can “nest” conditionals inside of one another. est_mass &lt;- function(volume, veg_type, age) { if (veg_type == &quot;tree&quot;) { # nested condition if (age &lt; 5) { mass &lt;- 1.6 * volume^0.8 } else { mass &lt;- 2.65 * volume^0.9 } } else if (veg_type == &quot;grass&quot; | veg_type == &quot;shrub&quot;) { mass &lt;- 0.65 * volume^1.2 } else { mass &lt;- NA } return(mass) } est_mass(1.6, &quot;tree&quot;, age = 2) ## [1] 2.330322 est_mass(1.6, &quot;shrub&quot;, age = 5) ## [1] 1.142503 Try to minimize nested functions whenever possible as it can be difficult to read. 3.3.3 Function arguments As seen previously, we can use custom inputs by defining an input argument. As lazy programmers, we usually want to call a function without typing much. This is where default arguments come in handy. For example, many of our shrubs are the same height so for those shrubs we only measure the length and width. We can set a default value for shrub height for cases where we don’t measure it. calc_shrub_vol &lt;- function(length, width, height = 1) { area &lt;- length * width volume &lt;- area * height return(volume) } calc_shrub_vol(0.8, 1.6) # default argument for height ## [1] 1.28 calc_shrub_vol(0.8, 1.6, 2.0) # default argument is overridden by 2,0 ## [1] 2.56 calc_shrub_vol(length = 0.8, width = 1.6, height = 2.0) ## [1] 2.56 As you could tell from the last two examples, you can override the default argument by providing your own value. Here are some additional points: You can always use names to assign a parameter to an argument. If not, using names then order is determined by parameter order. For example, First value is length, second value is width, third value is height. In many cases there are a lot of optional arguments. In this case, we can specify an argument by name to avoid confusion. Oftentimes, only the optional arguments are specified (i.e., those without a default value). In our case, we would write: calc_shrub_vol(0.8, 1.6, height = 2.0) ## [1] 2.56 3.3.4 Combining functions Here are some guidelines for creating good functions: Each function should be single conceptual chunk of code. Functions can be combined to perform larger tasks. est_shrub_mass &lt;- function(volume) { mass &lt;- 2.65 * volume^0.9 } shrub_volume &lt;- calc_shrub_vol(0.8, 1.6, 2.0) shrub_mass &lt;- est_shrub_mass(shrub_volume) We can nest functions. Below, the inner function executes before the outer function executes. shrub_mass &lt;- est_shrub_mass(calc_shrub_vol(0.8, 1.6, 2.0)) We need to be careful with this because nesting code can be difficult to read. As a general rule of thumb, don’t nest more than two functions. We can also call functions from inside other functions. This allows us to organize function calls into logical groups. est_shrub_mass_dim &lt;- function(length, width, height) { volume = calc_shrub_vol(length, width, height) mass &lt;- est_shrub_mass(volume) return(mass) } est_shrub_mass_dim(0.8, 1.6, 2.0) ## [1] 6.175354 Now that we’ve got the basics of R under our belts, we can jump into the fun data science applications! "]]
