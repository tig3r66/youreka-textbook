[
["basics-of-r-and-rstudio.html", "2 Basics of R and RStudio 2.1 Objects 2.2 Function Basics 2.3 Working directory 2.4 Basic math in R 2.5 Data structures in R 2.6 Conditionals 2.7 For loops 2.8 Functions", " 2 Basics of R and RStudio We begin our adventure with RStudio. If this is your first time opening RStudio, you should see the following panes: Console (entire left) Environment/History (upper right) Files/Plots/Packages/Help (lower right) You can change the default location of the panes, among many other things: Customizing RStudio. For now, place your cursor in the console so we can start coding with R! 2.1 Objects Here’s some basic information to get us started. R is an object-oriented programming language (OOP), meaning that R creates different types of objects that we can manipulate with functions and operators. Our first operator will be the assignment operator; either &lt;- (a left arrow) or = (the equal sign). Let’s make our first assignment and inspect the object we’ve just created: my_object &lt;- 5*10 my_object ## [1] 50 In plain English, the above snippet tells us that “five times ten is assigned to myObject”. Every value you assign to an object will be in this form: object_name &lt;- value By convention, we use &lt;- to assign variables. Don’t be lazy and use = to assign variables. Although this works, it will just sow confusion later. Instead, utilize RStudio’s keyboard shortcut: Alt+- (the minus sign). Notice that RStudio automagically surrounds &lt;- with spaces, which demonstrates a useful code formatting practice. Code is miserable to read on a good day. Give your eyes a break and use spaces. RStudio offers many handy keyboard shortcuts. The shortcut to rule them all is Alt+Shift+K, which brings up a keyboard shortcut reference card. Although object names are flexible, we do need to follow some rules: Object names cannot start with a digit and cannot contain certain other characters such as a comma or a space. As a general rule of thumb, object names should be short and meaningful. Misleading or overly long object names will make it a pain to debug your code. Below are examples of various object name conventions. My best advice would be to pick one and stick with it. this_is_snake_case other.people.use.periods evenOthersUseCamelCase Let’s make another assignment: this_is_a_really_long_name &lt;- 2.5 To inspect the object we’ve just created, try out RStudio’s auto-complete feature: type the first few characters, press TAB, add characters until you get what you want, then press return. 2.2 Function Basics Functions are always followed by a pair of brackets (). R has a huge collection of built-in functions that can be accessed like this: functionName(arg1 = val1, arg2 = val2, ...) Notice that we use = instead of &lt;- within a function. Here, arg1 and arg2 are called the arguments of the function functionName(). Likewise, val1 and val2 are called the parameters of arg1 and arg2. Let’s try using seq() which makes regular sequences of numbers and, while we’re at it, demo more helpful features of RStudio. Type se and hit TAB. A pop up shows you possible completions. Select seq() by using the up/down arrows to select. Notice the floating tool-tip-type help that pops up to remind you of a function’s arguments. If you want even more help, press F1 to get the full documentation in the help tab of the lower right pane. Now open the parentheses and notice the automatic addition of the closing parenthesis and the placement of cursor in the middle. Type the arguments 1, 10 and hit return. RStudio also exits the parenthetical expression for you. seq(1, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 The above also demonstrates something about how R resolves function arguments. You can always specify in name = value form. However if you don’t, R attempts to resolve by position. In the above snippet, R assumed that we want a sequence from = 1 that goes to = 10. Since we didn’t specify step size specified by the by argument. R uses the default value of 1 in this case. For functions I call often, I might use this resolve by position for the first argument or maybe the first two. After that, I always use name = value. seq(from = 1, to = 10, by = 2) ## [1] 1 3 5 7 9 Make this assignment and notice similar help with quotation marks. greeting &lt;- &quot;hello world&quot; If you just make an assignment, you don’t see the assigned value. To show the assigned value, just call the variable. y &lt;- seq(1, 10) y ## [1] 1 2 3 4 5 6 7 8 9 10 This common action can be shortened by surrounding the assignment with parentheses, which causes assignment and “print to screen” to happen. (y &lt;- seq(1, 10)) ## [1] 1 2 3 4 5 6 7 8 9 10 Not all functions have (or require) arguments: date() ## [1] &quot;Tue Dec 22 20:07:07 2020&quot; Now look at your workspace – in the upper right pane. The workspace is where user-defined objects accumulate. You can also get a listing of these objects with commands: objects() ## [1] &quot;greeting&quot; &quot;my_object&quot; ## [3] &quot;this_is_a_really_long_name&quot; &quot;y&quot; ls() ## [1] &quot;greeting&quot; &quot;my_object&quot; ## [3] &quot;this_is_a_really_long_name&quot; &quot;y&quot; If you want to remove the object named y, you can do this: rm(y) To remove everything: rm(list = ls()) or click the broom icon in RStudio’s Environment pane. 2.3 Working directory Any process running on your computer has a notion of its “working directory”. By default in R, a working directory is where R will look for files you ask it to load. It is also where any files you write to disk will go. You can explicitly check your working directory with: getwd() The working directory is also displayed at the top of the RStudio console. Notice that getwd() looks a lot like “get working directory”. As a beginning R user, it’s OK let your home directory or any other weird directory on your computer be R’s working directory. Very soon, I urge you to evolve to the next level, where you organize your analytical projects into directories and, when working on project A, set R’s working directory to the associated directory. In case you’re curious, you can set R’s working directory at the command line like so: setwd(&quot;~/myCoolProject&quot;) The setwd() function is extremely useful for times you want to read in external data, such as a .csv file. Now, let’s enter a few commands in the console, as if we are just beginning a project: a &lt;- 2 b &lt;- -3 sig_sq &lt;- 0.5 x &lt;- runif(40) y &lt;- a + b * x + rnorm(40, sd = sqrt(sig_sq)) (avg_x &lt;- mean(x)) ## [1] 0.5466695 plot(x, y) abline(a, b, col = &quot;purple&quot;) dev.print(pdf, &quot;toy_line_plot.pdf&quot;) Let’s say this is a good start of an analysis and your ready to start preserving the logic and code. Visit the History tab of the upper right pane. Select these commands. Click “To Source”. Now you have a new pane containing a new R script. Click on the floppy disk to save. Give it a name ending in .R or .r. Note that, by default, it will go in the directory associated with your project. Quit RStudio. Restart RStudio. Notice that things, by default, restore to where we were earlier (e.g. objects in the workspace, the command history, which files are open for editing, where we are in the file system browser, the working directory for the R process, etc.) Change some things about your code. Top priority would be to set a sample size n at the top (e.g. n &lt;- 40), and then replace all the hard-coded 40’s with n. Change some other minor-but-detectable stuff, e.g. alter the sample size n, the slope of the line b,the color of the line … whatever. Practice the different ways to re-run the code: Walk through line by line by keyboard shortcut (Command+Enter) or mouse (click “Run” in the upper right corner of editor pane). Source the entire document – equivalent to entering source('toy-line.r') in the console – using keyboard shortcut (Command+Shift+S) or mouse (click “Source” in the upper right corner of editor pane or select from the mini-menu accessible from the associated down triangle). One day you will want to remake a figure or just simply understand where it came from. If you rigorously save figures to file with R code and not ever ever ever the mouse or the clipboard, you will sing my praises one day. Trust me. 2.3.1 Other important things R scripts are usually saved with a .R or .r suffix. Use this convention unless you have some extraordinary reason not to. Comments start with one or more # symbols. Use them. RStudio helps you (de)comment selected lines with Ctrl+Shift+C (Windows and Linux) or Command+Shift+C (Mac). Clean out the workspace (i.e., pretend like you’ve just revisited this project after a long absence). You can do so by clicking the broom icon or by typing rm(list = ls()) into the console. This workflow will serve you well in the future: Create an RStudio project for an analytical project. Keep inputs there (we’ll soon talk about importing). Keep scripts there; edit them, run them in bits or as a whole from there. Keep outputs there. Avoid using your mouse for your workflow. Firstly, using the keyboard is faster. Secondly, writing code instead of clicking helps with reproducibility. That is, it will be much easier to retrospectively determine how a numerical table or PDF was actually produced. Many experienced users never save the workspace, never save .RData files (I’m one of them), and never save or consult the history. Once/if you get to that point, there are options available in RStudio to disable the loading of .RData and permanently suppress the prompt on exit to save the workspace (go to Tools &gt; Options &gt; General). 2.4 Basic math in R Here are some basic math operations you can perform in R: 1 + 2 # addition 5 * 4 # multiplication 10 / 3 # division 6 ^ 2 # exponentiation sqrt(5) # square root exp(1) # Euler&#39;s number pi # 3.14159... log(exp(1)) # base e logarithm log10(100) # base 10 logarithm 5 %% 2 # modular division round(1.5579, digits = 2) # rounding 2.5 Data structures in R Data structures determine the operations/methods/functions are available for each object. For example, you can do +/-/*// for numbers, but these operations will not be available for strings. What operations do you imagine would be useful for strings? paste(&quot;hello&quot;, &quot;world&quot;, sep = &quot;,&quot;) ## [1] &quot;hello,world&quot; Notice that single and double quotes can be used interchangeably, but double quotes are preferred. Single quotes are normally used to delimit characters within double quotes. 2.5.1 Vectors Vectors are a sequence of values with the same type. We can create vectors using c(), which stands for “combine”. (sites &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; To access the elements inside a vector, we can do something called “slicing”. To access a single item or multiple items, use the square bracket operator []. In general [] in R means, “give me a piece of something”. For example: sites[4] ## [1] &quot;c&quot; sites[1:3] ## [1] &quot;a&quot; &quot;a&quot; &quot;b&quot; In sites[1:3], the 1:3 creates a vector from 1 to 3, which is then used to subset multiple items in a vector. Here are some additional useful functions: length(sites) ## [1] 4 density_ha &lt;- c(2.8, 3.2, 1.5, 3.8) mean(density_ha) ## [1] 2.825 max(density_ha) ## [1] 3.8 min(density_ha) ## [1] 1.5 sum(density_ha) ## [1] 11.3 Now we turn our attention to multiple vectors. If our vectors are the same length, we can use math operations to combine each index element-wise. density_ha &lt;- c(2.8, 3.2, 1.5, 3.8) area_ha &lt;- c(3, 5, 1.9, 2.7) (total_number &lt;- density_ha * area_ha) ## [1] 8.40 16.00 2.85 10.26 Subsetting across multiple vectors is the same as that for a single vector: # recall: sites &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # recall: area_ha &lt;- c(3, 5, 1.9, 2.7) area_ha[sites == &quot;a&quot;] ## [1] 3 5 The above code snippet selects all members of area_ha at the indices where sites == 'a'. This brings us to another important concept: == means “does it equal to?” in most programming languages. == is not the same as =. This is why we use &lt;- to assign things instead of =. We can also ask the question of “does it not equal to?” area_ha[sites != &quot;a&quot;] ## [1] 1.9 2.7 Likewise, we can check “is it greater or less than?” sites[area_ha &gt; 3] ## [1] &quot;a&quot; sites[area_ha &gt;= 3] ## [1] &quot;a&quot; &quot;a&quot; sites[area_ha &lt; 3] ## [1] &quot;b&quot; &quot;c&quot; Notice that all the questions we ask have a “yes” (True) or “no” (False) answer. The operators associated with these questions are called Boolean operators. Finally, we can subset a vector based on itself. sites[sites != &quot;a&quot;] ## [1] &quot;b&quot; &quot;c&quot; 2.5.2 Missing values So far we’ve worked with data with no missing values. In real life, however, we often have missing values (NA values). Unfortunately for us, R does not get along with NA values. density_ha &lt;- c(2.8, 3.2, 1.5, NA) mean(density_ha) ## [1] NA Please note that NA is different from NULL. Take a look at the following example. na_vector &lt;- c(1, 2, 3, NA) null_vector &lt;- c(1, 2, 3, NULL) # look at the NA vector... na_vector ## [1] 1 2 3 NA # ... now look at the NULL vector null_vector ## [1] 1 2 3 # do the vectors work with a function such as mean()? mean(na_vector) ## [1] NA mean(null_vector) ## [1] 2 Why did we get NA? Well, it’s hard to say what a calculation including NA should be, so most calculations return NA when NA is in the data. One way to resolve this issue is to tell our function to remove the NA before executing: mean(density_ha, na.rm = TRUE) ## [1] 2.5 2.5.3 Data frames This is where things get really exciting! We will use these data structures extensively in the upcoming labs, so it’s important to pay attention here. A data frame is a list of equal length vectors grouped together. More importantly, a data frame can contain both categorical and numerical values, whereas a vector can only contain variables of the same type (i.e., all numerical, all categorical, etc.). surveys &lt;- data.frame(sites, density_ha, area_ha) surveys ## sites density_ha area_ha ## 1 a 2.8 3.0 ## 2 a 3.2 5.0 ## 3 b 1.5 1.9 ## 4 c NA 2.7 Here are some useful commands to investigate a data frame: str() returns the structure of a data frame. length() returns the length of a data frame. nrow() returns the number of rows of a data frame (same as length()) ncol() returns the number of columns of a data frame. str(surveys) ## &#39;data.frame&#39;:\t4 obs. of 3 variables: ## $ sites : Factor w/ 3 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: 1 1 2 3 ## $ density_ha: num 2.8 3.2 1.5 NA ## $ area_ha : num 3 5 1.9 2.7 length(surveys) ## [1] 3 nrow(surveys) ## [1] 4 ncol(surveys) ## [1] 3 Subsetting data frames is extremely similar to that for vectors. This time, however, we need to consider both rows and columns. We can access a specific member like this: my_data_frame[row, column] # visit one cell by row and column surveys[1, 2] ## [1] 2.8 # visit a range of rows and columns surveys[1:2, 2:3] ## density_ha area_ha ## 1 2.8 3 ## 2 3.2 5 # every row on the third column surveys[, 3] ## [1] 3.0 5.0 1.9 2.7 # visit column by name surveys[&#39;area_ha&#39;] ## area_ha ## 1 3.0 ## 2 5.0 ## 3 1.9 ## 4 2.7 # visit column by name (preferred method) surveys$area_ha ## [1] 3.0 5.0 1.9 2.7 # visit column by name surveys[[&#39;area_ha&#39;]] ## [1] 3.0 5.0 1.9 2.7 # visit multiple columns (preferred method) surveys[c(&#39;area_ha&#39;, &#39;sites&#39;)] ## area_ha sites ## 1 3.0 a ## 2 5.0 a ## 3 1.9 b ## 4 2.7 c 2.5.4 External data We can read in external data using theread.csv() function. The main argument is the location of the data, which is either a url or a path on your computer. shrub_data &lt;- read.csv(&#39;https://datacarpentry.org/semester-biology/data/shrub-dimensions-labeled.csv&#39;) 2.5.5 Factors Let’s use the str() function to get more information about our variable shrub_data. str(shrub_data) ## &#39;data.frame&#39;:\t10 obs. of 4 variables: ## $ shrubID: Factor w/ 10 levels &quot;a1&quot;,&quot;a2&quot;,&quot;b1&quot;,..: 1 2 3 4 5 6 7 8 9 10 ## $ length : num 2.2 2.1 2.7 3 3.1 2.5 1.9 1.1 3.5 2.9 ## $ width : num 1.3 2.2 1.5 4.5 3.1 2.8 1.8 0.5 2 2.7 ## $ height : num 9.6 7.6 2.2 1.5 4 3 4.5 2.3 7.5 3.2 Notice that the shrubID column has type Factor. A factor is a special data type in R for categorical data. Factors are useful for statistics, but can mess up some aspects of computation as we’ll see in future chapters. shrub_data &lt;- read.csv(&#39;https://datacarpentry.org/semester-biology/data/shrub-dimensions-labeled.csv&#39;, stringsAsFactors = FALSE) str(shrub_data) ## &#39;data.frame&#39;:\t10 obs. of 4 variables: ## $ shrubID: chr &quot;a1&quot; &quot;a2&quot; &quot;b1&quot; &quot;b2&quot; ... ## $ length : num 2.2 2.1 2.7 3 3.1 2.5 1.9 1.1 3.5 2.9 ## $ width : num 1.3 2.2 1.5 4.5 3.1 2.8 1.8 0.5 2 2.7 ## $ height : num 9.6 7.6 2.2 1.5 4 3 4.5 2.3 7.5 3.2 2.5.6 Lists Lists are a vector-like structure that can store other objects/data structures. It’s sort of like a vector that holds vectors. The main difference between a list and data frame is that lists can have elements with an unequal length. sites &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) notes &lt;- &quot;It was a good day in the field today. Warm, sunny, lots of gators.&quot; helpers &lt;- 4 field_notes &lt;- list(sites, notes, helpers) field_notes[1] ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; field_notes[[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; We can also give the values names and access them using the $ symbol (preferred) or via [&quot;variable_name&quot;] with subsetting. field_notes &lt;- list(my_sites = sites, notes = notes, my_helpers = helpers) field_notes$my_sites ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; field_notes[[&quot;my_sites&quot;]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 2.6 Conditionals Conditional statements checks if some condition is true or false using logical operators (operators that return either TRUE or FALSE). For example: weight &gt; 50 species == &quot;DM&quot; These statements return a value is of type &quot;logical&quot;, which is either TRUE(shorthand: T) if the condition is satisfied, or FALSE (shorthand: F) if the condition is not satisfied. Conditional statements are made with a range of logical operators. So far, We’ve seen: ==: is equals to !=: is not equals to &lt;, &gt;: is less than and greater than &lt;=, &gt;=: is less than or equal to and greater than or equal to is.na(): is NA There are other logical operators, including %in%, which checks if a value is present in a vector of possible values. Type the following statements into the console to see their output. &quot;aang&quot; == &quot;aang&quot; &quot;aang&quot; != &quot;kora&quot; 10 &lt; 5 10 &gt;= 5 is.na(&quot;toph&quot;) is.na(NA) &quot;zuko&quot; %in% c(&quot;aang&quot;, &quot;toph&quot;, &quot;katara&quot;) We can also combine conditions using the logical and (&amp;) along with the logical or (|). The logical &amp; returns TRUE if and only if both conditions are true, and it returns FALSE otherwise. Below is a truth table (don’t worry about memorizing it): P Q P &amp; Q P True True True True True False False True False True False True False False False False To contexualize this table, let’s look at the following examples: 5 &gt; 2 &amp; 6 &gt;=10 ## [1] FALSE 5 &gt; 2 | 6 &gt;=10 ## [1] TRUE We can also use logical operators on vectors. In the next example,we compare a vector to a single value, and operator returns one logical per value. c(1, 1, 2, 3, 1) == 1 ## [1] TRUE TRUE FALSE FALSE TRUE In English, the above snippet checks if each value in the vector is equal to 1. This is essentially what goes on behind the scenes when we try to subset a vector, except subsetting only returns where the subset condition is TRUE. Let’s look at an example where we have a vector of sites and a vector of US states they occur in. site &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) state &lt;- c(&#39;FL&#39;, &#39;FL&#39;, &#39;GA&#39;, &#39;AL&#39;) Now, let’s check if the state is 'FL'. This should return a vector of TRUE and FALSE. state == &#39;FL&#39; ## [1] TRUE TRUE FALSE FALSE Now, let’s filter the site vector to return values where the state is equal to 'FL'. site[state == &#39;FL&#39;] ## [1] &quot;a&quot; &quot;b&quot; The above snippet is the equivalent to passing a vector of TRUE and FALSE values inside the square brackets: site[c(TRUE, TRUE, FALSE, FALSE)] ## [1] &quot;a&quot; &quot;b&quot; 2.6.1 If statements Conditional statements generate logical values to filter inputs. if statements use conditional statements to control flow of a program. Below is the general form of an if statement: if (the conditional statement is TRUE) { do something } Let’s look at an example: x &lt;- 6 if (x &gt; 5) { x &lt;- x^2 } x ## [1] 36 x &gt; 5 is TRUE, so the code in the if runs x is now 6^2 or 36 Change x to 4 x &lt;- 4 if (x &gt; 5) { x &lt;- x^2 } x ## [1] 4 x &gt; 5 is FALSE, so the code in the if doesn’t run x is still 4 This is not a function, so everything that happens in the if statement influences the global environment Here’s a slightly more applied example: veg_type &lt;- &quot;tree&quot; volume &lt;- 16.08 if (veg_type == &quot;tree&quot;) { mass &lt;- 2.65 * volume^0.9 } mass ## [1] 32.27775 We often want to chose one of several options. We can add more conditions and associated actions with else if veg_type &lt;- &quot;grass&quot; volume &lt;- 16.08 if (veg_type == &quot;tree&quot;) { mass &lt;- 2.65 * volume^0.9 } else if (veg_type == &quot;grass&quot;) { mass &lt;- 0.65 * volume^1.2 } mass ## [1] 18.21615 Here, our script: 1. Checks the first condition 2. If TRUE runs that condition’s code and skips the rest 3. If not it checks the next one until it runs out of conditions We can specify what to do if none of the conditions are TRUE by using else on its own veg_type &lt;- &quot;shrub&quot; volume &lt;- 16.08 if (veg_type == &quot;tree&quot;) { mass &lt;- 2.65 * volume^0.9 } else if (veg_type == &quot;grass&quot;) { mass &lt;- 0.65 * volume^1.2 } else { mass &lt;- NA } mass ## [1] NA 2.6.2 Multiple “if”s vs “else if” Multiple ifs check each conditional separately, which is very inefficient. That is, R executes code for all conditions that are TRUE. x &lt;- 5 if (x &gt; 2) { x * 2 } ## [1] 10 if (x &gt; 4) { x * 4 } ## [1] 20 else if checks each condition sequentially, and ONLY executes code for the first condition that is TRUE x &lt;- 5 if (x &gt; 2) { x * 2 } else if (x &gt; 4) { x * 4 } ## [1] 10 2.7 For loops 2.7.1 Basic for loop Fundamental structure for repetition in programming Do same action to each item in a list of things for (item in list_of_items) { do_something(item) } Need print() to display values inside a loop or function. volumes = c(1.6, 3, 8) for (volume in volumes) { print(2.65 * volume^0.9) } ## [1] 4.045329 ## [1] 7.12287 ## [1] 17.21975 This does the same exact thing as volume &lt;- volumes[1] print(2.65 * volume ^ 0.9) ## [1] 4.045329 volume &lt;- volumes[2] print(2.65 * volume ^ 0.9) ## [1] 7.12287 volume &lt;- volumes[3] print(2.65 * volume ^ 0.9) ## [1] 17.21975 Can have many rows in a loop body for (volume in volumes){ mass &lt;- 2.65 * volume ^ 0.9 mass_lb &lt;- mass * 2.2 print(mass_lb) } ## [1] 8.899724 ## [1] 15.67031 ## [1] 37.88345 2.7.2 Looping with an index &amp; storing results Loops over integers and uses these integers to access the vector the associated positions for (i in 1:length(volumes)){ mass &lt;- 2.65 * volumes[i] ^ 0.9 print(mass) } ## [1] 4.045329 ## [1] 7.12287 ## [1] 17.21975 Use this “index” to get the values at that position Can use the “index” for multiple vectors Looping with an index allows us to store results calculated in the loop First create an empty vector the length of the results mode is the type of data we are going to store length is the length of the vector masses &lt;- vector(mode = &quot;numeric&quot;, length = length(volumes)) masses ## [1] 0 0 0 Then add each result in the right position For each trip through the loop put the output into the empty vector at the ith position for (i in 1:length(volumes)){ mass &lt;- 2.65 * volumes[i] ^ 0.9 masses[i] &lt;- mass } masses ## [1] 4.045329 7.122870 17.219751 Walk through iteration in debugger Looping with an index also allows us to access values from multiple vectors b0 &lt;- c(2.65, 1.28, 3.29) b1 &lt;- c(0.9, 1.1, 1.2) masses &lt;- vector(mode=&quot;numeric&quot;, length=length(volumes)) for (i in seq_along(volumes)){ mass &lt;- b0[i] * volumes[i] ^ b1[i] masses[i] &lt;- mass } 2.7.3 Looping over files (OPTIONAL) Repeat same actions on many similar files Get names of satellite collar location files data_files = list.files(path = &quot;data/02_intro-to-r&quot;, pattern = &quot;locations-.*.txt&quot;, full.names = TRUE) Calculate the number of observations in each file results &lt;- vector(mode = &quot;integer&quot;, length = length(data_files)) for (i in 1:length(data_files)){ data &lt;- read.csv(data_files[i]) count &lt;- nrow(data) results[i] &lt;- count } Store output in a data frame instead of a vector Associate the file name with the count results &lt;- data.frame(file_name = character(length(data_files)), count = integer(length(data_files)), stringsAsFactors = FALSE) for (i in 1:length(data_files)){ data &lt;- read.csv(data_files[i]) count &lt;- nrow(data) results$file_name[i] &lt;- data_files[i] results$count[i] &lt;- count } results ## file_name count ## 1 data/02_intro-to-r/locations-2016-01-01.txt 4 ## 2 data/02_intro-to-r/locations-2016-01-02.txt 8 ## 3 data/02_intro-to-r/locations-2016-01-03.txt 10 ## 4 data/02_intro-to-r/locations-2016-01-04.txt 10 ## 5 data/02_intro-to-r/locations-2016-01-05.txt 12 With apply get_counts &lt;- function(data_file_name){ file &lt;- read.csv(data_file_name) count &lt;- nrow(file) return(count) } results &lt;- unlist(lapply(data_files, get_counts)) results ## [1] 4 8 10 10 12 How to choose when there are many ways to do the same thing? Speed Matters in few cases Hard to identify bottlenecks Readability Easy to understand Personal preference There is no “right” way to do anything 2.7.4 Nested loops Sometimes need to loop over multiple things in a coordinate fashion Pass a window over some spatial data Look at full spatial pattern not just east-west gradient Basic nested loops work by putting one loop inside another one for (i in 1:3) { for (j in 1:5) { print(paste(&quot;i = &quot; , i, &quot;; j = &quot;, j)) } } ## [1] &quot;i = 1 ; j = 1&quot; ## [1] &quot;i = 1 ; j = 2&quot; ## [1] &quot;i = 1 ; j = 3&quot; ## [1] &quot;i = 1 ; j = 4&quot; ## [1] &quot;i = 1 ; j = 5&quot; ## [1] &quot;i = 2 ; j = 1&quot; ## [1] &quot;i = 2 ; j = 2&quot; ## [1] &quot;i = 2 ; j = 3&quot; ## [1] &quot;i = 2 ; j = 4&quot; ## [1] &quot;i = 2 ; j = 5&quot; ## [1] &quot;i = 3 ; j = 1&quot; ## [1] &quot;i = 3 ; j = 2&quot; ## [1] &quot;i = 3 ; j = 3&quot; ## [1] &quot;i = 3 ; j = 4&quot; ## [1] &quot;i = 3 ; j = 5&quot; Here’s a slightly more complex example that finds all prime numbers from 1 to 25: for (i in 2:25) { # assume each number is prime by default prime &lt;- TRUE for (j in 2:(i-1)) { # if i is divisible by any number from 2 to i-1, it is not a prime if (i%%j == 0) { prime &lt;- FALSE } } if (prime == TRUE | i == 2) { print(paste(i, &quot;is prime&quot;)) } } ## [1] &quot;2 is prime&quot; ## [1] &quot;3 is prime&quot; ## [1] &quot;5 is prime&quot; ## [1] &quot;7 is prime&quot; ## [1] &quot;11 is prime&quot; ## [1] &quot;13 is prime&quot; ## [1] &quot;17 is prime&quot; ## [1] &quot;19 is prime&quot; ## [1] &quot;23 is prime&quot; 2.8 Functions Sometimes, we wish to define our own functions. For example, we usually create functions if we need to do similar tasks more than once. Below is a basic format to write a function. function_name &lt;- function(arguments) { output_value &lt;- do_something(inputs) return(output_value) } The braces ({ and }) indicate that the lines of code are a group that gets run together. For example: {a = 2 b = 3 a + b} ## [1] 5 Pressing run anywhere in this group runs all the lines in that group. A function runs all of the lines of code in the braces using the arguments provided then returns the output calc_shrub_vol &lt;- function(length, width, height) { area &lt;- length * width volume &lt;- area * height return(volume) } Creating a function does not run it. A function is meant to be used: call the function with some arguments. calc_shrub_vol(0.8, 1.6, 2.0) ## [1] 2.56 Store the output to use it later in the program shrub_vol &lt;- calc_shrub_vol(0.8, 1.6, 2.0) Treat functions like a black box * Draw a box on board showing inputs-&gt;function-&gt;outputs * The only things the function knows about are the inputs we pass it * The only thing the program knows about the function is the output it produces Let’s walk through calc_shrub_vol()s execution: 1. Call function 2. Assign 0.8 to length, 1.6 to width, and 2.0 to height inside function 3. Calculate the area and assign it to area 4. Calculate volume and assign it to volume 5. Send volume back as output 6. Store it in shrub_vol Once again, treat functions like a black box. * You can’t access a variable that was created in a function. You must save the output of a function (to a variable) to use it later. * &gt; volume * Error: object 'width' not found * Or an argument by name * &gt; width * Error: object 'width' not found 2.8.1 Conditionals within functions Recall that we used a conditional to estimate mass differently for different types of vegetation. Since this is the kind of code we are going to want to reuse, so let’s move it into a function. est_mass &lt;- function(volume, veg_type) { if (veg_type == &quot;tree&quot;) { mass &lt;- 2.65 * volume^0.9 } else if (veg_type == &quot;grass&quot;) { mass &lt;- 0.65 * volume^1.2 } else { mass &lt;- NA } return(mass) } We can then run this function with different vegetation types and get different estimates for mass est_mass(1.6, &quot;tree&quot;) ## [1] 4.045329 est_mass(1.6, &quot;grass&quot;) ## [1] 1.142503 est_mass(1.6, &quot;shrub&quot;) ## [1] NA Let’s walk through how this code executes: 1. When we call the function the first thing that happens is that 1.6 gets assigned to volume and &quot;shrub&quot; gets assigned to veg_type 2. The code then checks to see if veg_type is equal to &quot;tree&quot; 3. It isn’t so the code then checks to see if veg_type is equal to &quot;grass&quot; 4. It is so the code then hits the else statement and executes the code in the else block 5. It assigns NA to mass 6. It then finishes the if/else if/else statement and returns the value for mass, which is NA to the global environment 2.8.2 Nested conditionals Sometimes decisions are more complicated For example we might have different equations for some vegetation types based on the age of the plant Can “nest” conditionals inside of one another est_mass &lt;- function(volume, veg_type, age){ if (veg_type == &quot;tree&quot;) { if (age &lt; 5) { mass &lt;- 1.6 * volume^0.8 } else { mass &lt;- 2.65 * volume^0.9 } } else if (veg_type == &quot;grass&quot; | veg_type == &quot;shrub&quot;) { mass &lt;- 0.65 * volume^1.2 } else { mass &lt;- NA } return(mass) } est_mass(1.6, &quot;tree&quot;, age = 2) ## [1] 2.330322 est_mass(1.6, &quot;shrub&quot;, age = 5) ## [1] 1.142503 Here’s how the function executes: 1. First checks if the vegetation type is “tree” 2. If it is checks to see if it is &lt; 5 years old 3. If so does one calculation, if not does another. Note that nesting can be difficult to read so try to minimize it when possible. 2.8.3 Default arguments and unnamed arguments Defaults can be set for common inputs. For example, many of our shrubs are the same height so for those shrubs we only measure the length and width. So we want a default value for the height for cases where we don’t measure it calc_shrub_vol &lt;- function(length, width, height = 1) { area &lt;- length * width volume &lt;- area * height return(volume) } calc_shrub_vol(0.8, 1.6) # default argument for height ## [1] 1.28 calc_shrub_vol(0.8, 1.6, 2.0) # default argument is overridden by 2,0 ## [1] 2.56 calc_shrub_vol(length = 0.8, width = 1.6, height = 2.0) ## [1] 2.56 As you could tell from the last two examples, you can specify the arguments (parameters) with or without their names. You can always use names to assign a parameter to an argument. If not, using names then order is determined by parameter order. For example, First value is length, second value is width, third value is height. In many cases there are a lot of optional arguments. In this case, we can specify an argument by name to avoid confusion. Oftentimes, only the optional arguments are specified (i.e., those without a default value). In our case, we would write: calc_shrub_vol(0.8, 1.6, height = 2.0) ## [1] 2.56 2.8.4 Combining functions Here are some guidelines for creating functions: * Each function should be single conceptual chunk of code * Functions can be combined to do larger tasks est_shrub_mass &lt;- function(volume) { mass &lt;- 2.65 * volume^0.9 } shrub_volume &lt;- calc_shrub_vol(0.8, 1.6, 2.0) shrub_mass &lt;- est_shrub_mass(shrub_volume) We can nest functions. Below, the inner function executes before the outer function executes. shrub_mass &lt;- est_shrub_mass(calc_shrub_vol(0.8, 1.6, 2.0)) We careful with this because it can make code difficult to read. As a general rule of thumb, don’t nest more than two functions. We can also call functions from inside other functions. This allows us to organize function calls into logical groups. est_shrub_mass_dim &lt;- function(length, width, height) { volume = calc_shrub_vol(length, width, height) mass &lt;- est_shrub_mass(volume) return(mass) } est_shrub_mass_dim(0.8, 1.6, 2.0) ## [1] 6.175354 "]
]
